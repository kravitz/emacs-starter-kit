#+TITLE: Haru.org
#+OPTIONS: H:3 num:nil toc:nil \n:nil @:t ::t |:t ^:t -:t f:t *:t TeX:t LaTeX:nil skip:nil d:t tags:not-in-toc
#+STARTUP: INDENT

1. Включение красивой расцветки -- цветовой темы zenburn
   #+begin_src emacs-lisp :tangle yes
     (require 'zenburn) (color-theme-zenburn)
   #+end_src

2. Второй язык — русский.
   #+begin_src emacs-lisp
     (set-input-method 'russian-computer)
     (inactivate-input-method)
   #+end_src

3. *M-Space* — переключение между языками. Две легко доступные,
    вплотную расположенные клавиши — это лучший вариант. Эта
    комбинация пересекается с вызовом «меню окна» в среде GNOME, но в
    гноме я отключил это сочетание за ненадобностью.
    #+begin_src emacs-lisp
      (global-set-key (kbd "M-SPC") 'toggle-input-method)
    #+end_src

4. *F11* включает полноэкранный режим. Требует наличия программы
   *wmctrl*.
   #+begin_src emacs-lisp
     (defun switch-full-screen ()
       (interactive)
       (shell-command "wmctrl -r :ACTIVE: -btoggle,fullscreen"))
     (global-set-key [f11] 'switch-full-screen)
   #+end_src

5. *Smart Tab* — говорит само за себя. Код взят с [[http://www.emacswiki.org/emacs/TabCompletion][Emacs Wiki]], цельный
   пакет кода смотреть на [[https://github.com/genehack/smart-tab][Gihub]].
   #+begin_src emacs-lisp
     (setq hippie-expand-try-functions-list
           '(;yas/hippie-try-expand
             try-expand-dabbrev
             try-expand-dabbrev-all-buffers
             try-expand-dabbrev-from-kill
             try-complete-file-name
             try-complete-lisp-symbol))

     (defvar smart-tab-using-hippie-expand t
       "turn this on if you want to use hippie-expand completion.")

     (defun smart-tab (prefix)
       "Needs `transient-mark-mode' to be on. This smart tab is
          minibuffer compliant: it acts as usual in the minibuffer.

          In all other buffers: if PREFIX is \\[universal-argument], calls
          `smart-indent'. Else if point is at the end of a symbol,
          expands it. Else calls `smart-indent'."
       (interactive "P")
       (labels ((smart-tab-must-expand (&optional prefix)
                                       (unless (or (consp prefix)
                                                   mark-active)
                                         (looking-at "\\_>"))))
         (cond ((minibufferp)
                (minibuffer-complete))
               ((smart-tab-must-expand prefix)
                (if smart-tab-using-hippie-expand
                    (hippie-expand prefix)
                  (dabbrev-expand prefix)))
               ((smart-indent)))))

     (defun smart-indent ()
       "Indents region if mark is active, or current line otherwise."
       (interactive)
       (if mark-active
           (indent-region (region-beginning)
                          (region-end))
         (indent-for-tab-command)))
   #+end_src
   #+begin_src emacs-lisp
      (global-set-key (kbd "TAB") 'smart-tab)
   #+end_src

6. Настраиваем haskell-mode
   #+BEGIN_SRC emacs-lisp
     (add-hook 'haskell-mode-hook 'turn-on-haskell-doc-mode)
     (add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
   #+END_SRC

7. Добавляем фортунки, доблестно забрано с руководства от zahardzhan
   http://zahardzhan.github.com/2011/fortunes-for-emacs.html
   #+begin_src emacs-lisp
     (defvar fortune-file "~/.emacs.d/fortunes"
       "The file that fortunes come from.")   
   #+end_src
   Функция fortune выбирает из файла случайную фортунку.
   #+begin_src emacs-lisp
     (defvar fortune-strings nil
          "The fortunes in the fortune file.")
        
          (defun open-fortune-file (file)
            (find-file file)
            (if (null fortune-strings)
                (let ((strings nil)
                  (prev 1))
              (goto-char (point-min))
              (while (re-search-forward "^%$" (point-max) t)
                (push (buffer-substring-no-properties prev (- (point) 1))
                      strings)
                (setq prev (1+ (point))))
              (push (buffer-substring-no-properties prev (point-max)) strings)
              (setq fortune-strings (apply 'vector strings)))))
          
          (defun fortune ()
            "Get a fortune to display."
            (interactive)
            (when (null fortune-strings)
              (open-fortune-file fortune-file)
              (kill-buffer (current-buffer)))
            (let* ((n (random (length fortune-strings)))
               (string (aref fortune-strings n)))
              (if (interactive-p)
              (message (format "%s" string))
              string)))
   #+end_src
   Заменяем функцию, показывающую при запуске текст в *scratch*-буфере на
   собственную
   #+begin_src emacs-lisp
     (defun startup-echo-area-message ()
     (interactive)
     (let ((start (point))
           (buffer-was-modified? (buffer-modified-p)))
       (insert (fortune))
       (comment-region start (point))
       (newline)
       (unless buffer-was-modified?
         (not-modified))))
   #+end_src
